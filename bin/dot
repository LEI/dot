#!/usr/bin/env bash

set -o nounset
set -o errexit
set -o pipefail

# SRC="$(readlink "${BASH_SOURCE[0]}" || realpath "${BASH_SOURCE[0]}")"
SRC="$(readlink "${BASH_SOURCE[0]}" || echo "${BASH_SOURCE[0]}")"
DIR="$(cd "$(dirname "$SRC")/.." && pwd -P)"

# cd "$DIR"

for path in $DIR/lib/*.bash
do source "$path"
done

# source ./lib/*.bash

# Stop expansion
set -f

UNAME="$(uname -s | tr "[:upper:]" "[:lower:]")"

ENV_VARS="HOME PWD OSTYPE UNAME"

OPTS=
RC=".dotrc"
SH=".dotsh"
TARGET="$HOME"
DRY_RUN=0
VERBOSE=0
INTERACTIVE=1

export UNAME DRY_RUN VERBOSE INTERACTIVE

usage() {
  local ret="$?"
  local cmd="${0##*/}"
  if [[ $# -ne 0 ]]
  then ret="$1"; shift
  fi
  if [[ $# -ne 0 ]]
  then err "$cmd: $*"
  fi
  usage_exit "$ret" "Usage: $cmd [install|remove] $OPTS"
}

parse_config() {
  local file="$1"
  shift
  local args=("$@")
  # [[ $# -ne 2 ]] && usage 1 "extra args"
  if [[ -f "$file" ]] # && [[ "$no_source" -eq 0 ]] # --no-auto-source
  then
    if [[ "${#args[@]}" -ne 0 ]]
    then exec_file "$file" "${args[@]}" "$dir"
    else exec_file "$file" "$dir"
    fi
  fi
}

env_sub() {
  local s str="$1"
  for s in $ENV_VARS
  do
    # >&2 echo "$s -> $str"
    if [[ "$str" == *\$$s* ]]
    then str="${str//\$$s/${!s}}"
    elif [[ "$str" == *\$\{$s\}* ]]
    then str="${str//\${$s}/${!s}}"
    fi
  done
  printf "%s\n" "$str"
}

exec_file() {
  local file="$1"
  shift
  local args=("$@")
  local l=
  local lines=()
  local line args
  local var val
  if [[ ! -f "$file" ]]
  then err "$file: no such file"; return 1
  fi
  while read -r line
  do # Disable wildcard expansion ${line//\*/\\*}
    # line="${line###*}"
    line="${line%% # *}"
    [[ -z "$line" ]] && continue
    # [[ "$line" =~ ^#* ]] && continue
    [[ "$line" == "#"* ]] && continue
    [[ -n "$l" ]] && line="${l%\\}$line"
    if [[ "$line" =~ \\$ ]]
    then l="$line"; continue
    elif [[ "$line" =~ ^[a-zA-Z]+=* ]]
    then var="${line%%=*}"; val="${line#*=}"
      declare "$var=$val" # && ENV_VARS+=" $var"
      >&2 log "declared $var=$val"
    # else set -f; reset_expansion main --no-auto-source $a $(PWD="$(dirname "$file")" env_sub "$line")
    # reset_expansion() { local cmd="$1"; shift; $cmd "$@"; set +f; }
    else
       # echo lines+="${args[@]} $line"
       #  && line="${args[*]} $line"
       # if [[ "${#args[@]}" -ne 0 ]]
       lines+=("$line ${args[@]:-}")
       # main $line ${args[@]:-}
    fi; l=
  done < "$file"
  # echo lines "${lines[@]}"
  for l in "${lines[@]}"
  do set -- $l; main $l
    # eval main $l || { err "main $l"; return $?; }
  done
}

clean_symlinks() {
  local path="${1:-$TARGET}"
  local link real_link
  while read -r l
  do real_link="$(readlink "$link")"
    if [[ -n "$real_link" ]] && [[ "$DIR" == "$real_link"* ]]
    then >&2 log "Removing broken symlink '$link'"; rm "$link"
    fi
  done < <(find "$path" -maxdepth 3 -type l -exec test ! -e {} \; -print)
}

parse_opts() {
  init_opts
  local n
  # echo >&2 "OPTS [$#] $*"
  OPTS="[hDveustRcnp]"
  while [[ $# -ne 0 ]]
  do n=1
    # echo >&2 "[$#] '$1'"
    case "$1" in
      --) shift; break ;;
      install) [[ -n "$state" ]] && usage 1 "$1: already set ($state)"
        state="$1"; action=link_file ;;
      remove) [[ -n "$state" ]] && usage 1 "$1: already set ($state)"
        state="$1"; action=remove_link ;;
      -D|--dry-run) DRY_RUN=1 ;;
      -v|--verbose) VERBOSE="$((VERBOSE + 1))" ;;
      -h|--help) usage ;;

      # -u|--upstream) shift; upstream="$1" ;;
      --clean-symlinks) shift; clean_symlinks "${1:-$TARGET}"; exit $? ;;
      --prefix) shift; prefix="$1" ;;
      # -s|--source) shift; exec_file "$1" --no-auto-source "${@:2}"; echo "$# parameters left"; return $? ;;
      --no-auto-source) no_source=1 ;;

      --non-interactive) INTERACTIVE=0 ;;

      -t|--target) shift; target="$1" ;;
      # -R|--root-dir) shift; dir="$(env_sub "$1")" ;;

      -c|--create|--create-dir) shift; create_dirs+=("$(env_sub "$1")") ;;
      -n|--name|--find-name) shift; find_names+=("$(env_sub "$1")") ;;
      -p|--path|--find-path) shift; find_paths+=("$(env_sub "$1")") ;;
      # -d|--dir|--find-dir) shift; find_dirs+=("$1") ;;

      -e|--extra-option) shift; # find_opts+=("$1"); next="-e"
        while [[ $# -ne 0 ]]
        do case "$1" in -*) break ;;
          *=*) find_opts+=("-${1%%=*}" "${1#*=}") ;;
          *) find_opts+=("-$1") ;;
        esac; shift
        done; n=0 ;;

      --min-depth) shift; min_depth="$1" ;;
      --max-depth) shift; max_depth="$1" ;;
      --*|'') >&2 log "$1: illegal option $OPTS"; return 1 ;;
      -*) if [[ "$1" =~ ^-[a-zA-Z][a-zA-Z]+$ ]] && [[ "${1:1:1}" =~ $OPTS ]]
        then set -- "${1:0:2}" "-${1:2}" "${@:2}"; continue
        else >&2 log "${1:0:2}: illegal option $OPTS"; return 1
        fi ;;
      *) # if [[ -n "$next" ]]
        # then set -- "$next" "$@"; n=0; next=
        if [[ $# -ne 0 ]] # && [[ -z "$dir" ]]
        then dir="$1"
        else >&2 log "$1: unrecognized option $OPTS"; return 1
        fi ;;
    esac
    shift ${n:-1}
  done

  # [[ "$INTERACTIVE" -eq 0 ]] && log "Non interactive"
  # [[ "$DRY_RUN" -ne 0 ]] && log "Running in check mode!"
  # [[ "$VERBOSE" -gt 1 ]] & log "Log level: $VERBOSE"
  # state="${state:-$state_default}"
  if [[ -n "$state" ]] && \
    [[ "$state" != "$state_install" ]] && \
    [[ "$state" != "$state_remove" ]]
  then usage 1 "$state: illegal command"
  else state="$state_default"
  fi

  [[ -z "$dir" ]] && usage 1 "missing root dir"
  # dir="${dir:-$DIR}"

  if [[ -n "$dir" ]] && [[ -n "$prefix" ]]
  then dir+="/$prefix"
  fi

  # Remove trailing slash
  if [[ -d "$dir" ]]
  then dir="${dir%/}"
  else usage 1 "$dir: not a directory"
  fi
}

build_find_opt() {
  local ope="$1"
  shift
  local opt="$1"
  shift
  local pre="$1"
  shift
  local f
  for f in "$@"
  do local t=
    [[ "${#find_opts[@]}" -ne 0 ]] && find_opts+=("$ope")
    [[ "$f" == *:* ]] && t="${f%%:*}"; f="${f#*:}"
    [[ -n "$t" ]] && find_opts+=("(" "-type" "$t")
    [[ -n "$pre" ]] && f="$pre/$f"
    find_opts+=("$opt" "$f")
    [[ -n "$t" ]] && find_opts+=(")")
  done
}

build_find_cmd() {
  if [[ "${#find_ignore[@]}" -ne 0 ]]
  then # [[ "${#find_opts[@]}" -eq 0 ]] && find_opts+=("!")
    build_find_opt "!" "-path" "$dir" "${find_ignore[@]}"
  fi
  [[ "${#find_names[@]}" -ne 0 ]] && build_find_opt "-o" "-name" "" "${find_names[@]}"
  [[ "${#find_paths[@]}" -ne 0 ]] && build_find_opt "-o" "-path" "$dir" "${find_paths[@]}" # /#/$dir/
  if [[ "${#find_opts[@]}" -ne 0 ]]
  then
    find_cmd=("find" "$dir" "-mindepth" "$min_depth" "-maxdepth" "$max_depth" "${find_opts[@]}")
    if [[ "$VERBOSE" -gt 1 ]]
    then >&2 log "${find_cmd[@]}"
    fi
  fi
}

bootstrap() {
  if [[ "$no_source" -eq 0 ]] && [[ -f "$dir/$SH" ]]
  then
    if source "$dir/$SH" && hash "_$state" 2>/dev/null
    then "_$state"; unset "_$state"
    fi
  fi

  if [[ "${#create_dirs[@]}" -ne 0 ]]
  then
    if [[ "$state" == "install" ]]
    then create_dir "${create_dirs[@]/#/$target/}"
    fi
  fi

  if build_find_cmd && [[ -n "${find_cmd[@]}" ]]
  then
    local src dst
    while read -r src <&3
    do dst="${src/$dir/$target}"
       $action "$src" "$dst"
    done 3< <("${find_cmd[@]}")
  # elif [[ "${#find_opts[@]}" -eq 0 ]] && [[ "${#create_dirs[@]}" -eq 0 ]]
  # then usage 1 "missing options -D <dir>, -F <name> or -P <path> ${find_opts[@]:-}"
  fi

  if [[ "${#create_dirs[@]}" -ne 0 ]]
  then
    if [[ "$state" == "remove" ]]
    then remove_dir "${create_dirs[@]/#/$target/}"
    fi
  fi

  if [[ "$no_source" -eq 0 ]] && [[ -f "$dir/$SH" ]] && hash "_post_$state" 2>/dev/null
  then "_post_$state"; unset "_post_$state"
  fi
}

init() {
  state_default="install"
  state_install="install"
  state_remove="remove"
  # role="$(pwd -P)"
  no_source=0
  target="$TARGET"
  find_ignore=("*$RC" "*$SH" "*.git" "*.gitkeep" "*.md" "*.tpl")
  min_depth=1
  max_depth=2
}

init_opts() {
  state=
  action=link_file
  dir="$DIR"
  prefix=
  create_dirs=()
  find_names=()
  find_paths=()
  # find_dirs=()
  find_opts=()
  find_cmd=()
  # declare -a find_opts
}

main() {
  # >&2 echo "main @ $* (dir:${dir:-noDir})"
  init
  parse_opts "$@"
  local dotrc
  dotrc="$dir/$RC"
  if [[ -f "$dotrc" ]]
  then parse_config "$dir/$RC"
  else
    log "[${state} ${dir#*/}]"
    bootstrap
    log "[${state%e}ed ${dir#*/}]"
  fi

  log "Done [$?]"
}

symlink() {
  # >&2 echo "symlink @ $* (dir:$dir, prefix:$prefix)"
  [[ -z "$prefix" ]] && usage 1 "missing prefix in '$*'"
  parse_opts --no-auto-source --prefix "$prefix" "$@"
  log "[${dir##*/} symlinks]"
  bootstrap
  log "[${dir##*/} symlinks ]"
}

[[ "$0" == "$BASH_SOURCE" ]] && main "$@"
